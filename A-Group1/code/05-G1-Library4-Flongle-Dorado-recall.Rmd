---
title: "05-G1-Library4-Flongle-Dorado-recall"
author: "Kathleen Durkin"
date: "2025-10-27"
always_allow_html: true
output: 
  github_document:
    toc: true
    toc_depth: 3
    number_sections: true
    html_preview: true 
  bookdown::html_document2:
    theme: cosmo
    toc: true
    toc_float: true
    number_sections: true
    code_folding: show
    code_download: true
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(
  echo = TRUE,         # Display code chunks
  eval = FALSE,        # Evaluate code chunks
  warning = FALSE,     # Hide warnings
  message = FALSE,     # Hide messages
  comment = ""         # Prevents appending '##' to beginning of lines in code output
)
```

```{r}
library(ggplot2)
library(tidyr)
library(tidyverse)
library(dplyr)
```


# Create a Bash variables file

This allows usage of Bash variables (e.g. paths to common directories) across R Markdown chunks.
```{r save-bash-variables-to-rvars-file, engine='bash', eval=TRUE}
{
echo "#### Assign Variables ####"
echo ""

echo "# Data directories"
echo 'export nanopore_dir=/home/shared/8TB_HDD_02/shedurkin/SIFP-nanopore'
echo 'export output_dir_top=${nanopore_dir}/A-Group1/output/05-G1-Library4-Flongle-Dorado-recall'
echo 'export data_dir_top=${nanopore_dir}/A-Group1/data/05-G1-Library4-Flongle-Dorado-recall'
echo 'export raw_pod5_dir=${data_dir_top}/pod5'
echo 'export raw_pod5_url="https://gannet.fish.washington.edu/kdurkin1/SIFP_2025/Group1_Flongle/Group1/Library4/20250818_1549_MD-101223_AYL248_54e75371/pod5/"'
echo 'export dorado_models_dir=${nanopore_dir}/dorado-models'
echo 'export genome_dir=${nanopore_dir}/data/GCA_965233905.1_jaEunKnig1.1/'

echo "# Paths to programs"
echo 'export modkit=/home/shared/dist_modkit_v0.5.1_8fa79e3/modkit'
echo 'export samtools=/home/shared/samtools-1.12/samtools'
echo 'export dorado=/home/shared/dorado-1.2.0-linux-x64/bin/dorado'
echo ""

echo "# Set pod5 filename patterns"
echo "export pod5_pattern='*.pod5'"
echo ""

echo "# Set number of CPUs to use"
echo 'export threads=20'
echo ""

echo "# Input/output files"
echo 'export raw_checksums=checksums.md5'
echo 'export trimmed_checksums=trimmed_fastq_checksums.md5'
echo ""
} > .bashvars

cat .bashvars
```

# Raw reads
## Download raw pod5 files

Reads are downloaded from: https://gannet.fish.washington.edu/kdurkin1/SIFP_2025/Group1_Flongle/Group1/Library4/20250818_1549_MD-101223_AYL248_54e75371/pod5/

Note that this directory contains multiple subdirectories, each representing one barcode (specimen) and containing the fastq.gz files associated with that barcode

The `--cut-dirs 7` command cuts the preceding directory structure (i.e. `nightingales/P_evermanni/30-789513166/`) so that we just end up with the reads.

```{r download-raw-reads, engine='bash', eval=FALSE}
# Load bash variables into memory
source .bashvars

wget \
--directory-prefix ${raw_pod5_dir} \
--recursive \
--no-check-certificate \
--continue \
--cut-dirs 6 \
--no-host-directories \
--no-parent \
--quiet \
--accept ${pod5_pattern} ${raw_pod5_url}
```

```{r check-raw-reads, engine='bash', eval=TRUE}
# Load bash variables into memory
source .bashvars

ls -lh "${raw_pod5_dir}"
```

## Verify raw read checksums
```{r verify-raw-read-checksums, engine='bash', eval=FALSE}
# Load bash variables into memory
source .bashvars

wget \
--directory-prefix ${raw_pod5_dir} \
--recursive \
--no-check-certificate \
--continue \
--cut-dirs 6 \
--no-host-directories \
--no-parent \
--quiet \
--accept 'checksums.md5' ${raw_pod5_url}

cd "${raw_pod5_dir}"

# Recursively verify checksums in all subdirectories
find $(pwd) -type d | while read -r DIR; do
    # Check if checksums.md5 exists in this directory
    if [[ -f "$DIR/checksums.md5" ]]; then
        echo "Verifying checksums in $DIR"
        (
            cd "$DIR" || exit 1
            md5sum -c checksums.md5
        )
        echo ""
    fi
done
```


# Dorado basecaller

We want to demultiplex and trim adapter and barcode sequences

Notes:

- When selecting multiple modification models, only one modification per canonical base may be active at once. For example, sup,4mC,5mC is invalid as both modification models operate on the C canonical base context.

- Since basecalling is GPU-intensive, but alignment is CPU-intensive, including alignment during basecalling shouldn't have a significant impact on throughput

- Dorado uses `minimap2` for alignment by default, which seems to be more of a k-mer-based pseudoalignment

- When using alignment during basecalling, no reads are excluded following alignment. All reads are basecalled. Then, reads that do not align to the provided reference are included in the output SAM/BAM as *unmapped* reads, with the appropriate tags. If you want to exclude unmapped reads, you'll have to do that *after* basecalling

```{bash}
source .bashvars

# --trim 'all': will trim adapter, primer (if present) and barcode sequences
# --kit-name <kit-name>: allows simultaneous demultiplexing, with which the trimming does not interfere
# --reference: allows basecalling with alignment
# --modified-bases: allows for modified basecalling, space-separated. Note that, for cytosine modifications, there are options for calling modifications on *all* cytosines, and for calling modifications that occur *specifically* in a CG context. Cannot specify modifications that occur on same base (e.g., cannot simultaneously call 4mC and 5mCG)

# --trim: 'all', trim adapter and barcodes
# --kit-name: specifying the library prep i used, Native Barcoding V14 96
# --reference: aligning to Eunicea knighti genome (closest published relative of Eunicea tourneforti)
# -- modified-bases: 5mCG_5hmCG calls 5mC and 5hmC occuring in CG contexts; 6mA calles 6mA modifications.

$dorado basecaller \
hac \
-r ${raw_pod5_dir}/ \
--kit-name SQK-NBD114-96 \
--trim 'all' \
--reference ${genome_dir}/GCA_965233905.1_jaEunKnig1.1_genomic.fna \
--modified-bases 5mCG_5hmCG 6mA \
> ${output_dir_top}/AYL248_recalled.bam

```

# BAM processing

Separate out mapped reads, and separate by barcode

```{r, engine='bash', eval=TRUE}
source .bashvars

cd ${output_dir_top}

# Alignment summary
$samtools flagstat -O tsv AYL248_recalled.bam > AYL248_recalled_summary.tsv
cat AYL248_recalled_summary.tsv
```

From the samtools `flagstat` summary we see a high alignment rate (89.68%), which is great! The vast majority of reads confidently come from *Eunicea*. There are, however, a lot of "secondary" and "supplementary" reads. "Secondary" indicates secondary alignments, i.e. alternative mapping locations of the same read. "Supplementary" indicates supplementary alignments, or parts of a read that align *discontinuously* (possibly chimeric, split, large structural variants, etc.). The true number of reads present in my sample is just the *primary* alignments (total - secondary - supplementary = 134052-77531-7462 = 49,059 reads). This is a rather annoying artifact of Dorado using a multimapper inder the hood, where a single read can be mapped to multiple possible loci (one primary and 0 or more secondary). For downstream work, we only want to be using the "real" reads, not duplicate records of secondary/supplementary alignments, so we need to filter those out of the BAM. We also need to sort them

```{bash}
source .bashvars

cd ${output_dir_top}

# Remove unmapped reads (bit decimal 4), secondary alignments (bit decimal 256) and supplementary alignments (bit decimal 2048)
$samtools view -b -F 2308 AYL248_recalled.bam |\
$samtools sort -o AYL248_recalled_mapped.bam

# Separate by barcode
$samtools view -h AYL248_recalled_mapped.bam |\
awk '/^@/ || /BC:Z:SQK-NBD114-96_barcode12/' |\
$samtools view -b |\
$samtools sort -o AYL248_recalled_mapped_barcode12.bam

$samtools view -h AYL248_recalled_mapped.bam |\
awk '/^@/ || /BC:Z:SQK-NBD114-96_barcode13/' |\
$samtools view -b |\
$samtools sort -o AYL248_recalled_mapped_barcode13.bam

$samtools view -h AYL248_recalled_mapped.bam |\
awk '/^@/ || /BC:Z:SQK-NBD114-96_barcode14/' |\
$samtools view -b |\
$samtools sort -o AYL248_recalled_mapped_barcode14.bam


```

Index
```{bash}
source .bashvars
cd ${output_dir_top}

$samtools index AYL248_recalled_mapped.bam
$samtools index AYL248_recalled_mapped_barcode12.bam
$samtools index AYL248_recalled_mapped_barcode13.bam
$samtools index AYL248_recalled_mapped_barcode14.bam

```


# Summary stats

```{r, engine='bash', eval=TRUE}
source .bashvars

cd ${output_dir_top}

# Alignment summary
$samtools flagstat -O tsv AYL248_recalled_mapped.bam > flagstat_summary_AYL248_recalled_mapped.tsv
cat flagstat_summary_AYL248_recalled_mapped.tsv

echo ""

# Summarize by barcode
$samtools view AYL248_recalled_mapped.bam | \
awk '{for(i=12;i<=NF;i++) if($i ~ /^BC:Z:/) {print substr($i,6)}}' | \
sort | uniq -c | sort -nr
```

So the actual alignment rate (# of mapped primary alignments/# of total primary alignments) is actually 35,226/49,059 = 71.8%. This is still a pretty good alignment rate! 

There's also a bit of a discrepancy among the barcodes. Barcodes 12 and 13 each have 9-10k reads, while Barcode 14 has almost 15k.

Note also that the sum of reads with different barcodes is slightly less than our total of 35226 mapped primary reads. This is because reads that were not successfully demultiplexed were not assigned a barcode tag.

## modkit modification summaries

Summarize modifications
```{r, engine='bash', eval=TRUE}
source .bashvars

$modkit summary ${output_dir_top}/AYL248_recalled_mapped.bam
```

In mapped, primary-alignment reads, we observe negligible 6mA (~0.5%), low/negligible 5hmCG (~1%), and moderately-low 5mCG (~5%)

Now let's check by barcode (individual)

```{r, engine='bash', eval=TRUE}
source .bashvars

cd ${output_dir_top}

$modkit summary --tsv AYL248_recalled_mapped_barcode12.bam > modkit_summary_AYL248_barcode12.tsv

echo ""

$modkit summary --tsv AYL248_recalled_mapped_barcode13.bam > modkit_summary_AYL248_barcode13.tsv

echo ""

$modkit summary --tsv AYL248_recalled_mapped_barcode14.bam > modkit_summary_AYL248_barcode14.tsv
```

Barplot of above modkit summaries
```{r, eval=TRUE}

files <- c(
  "../output/05-G1-Library4-Flongle-Dorado-recall/modkit_summary_AYL248_barcode12.tsv",
  "../output/05-G1-Library4-Flongle-Dorado-recall/modkit_summary_AYL248_barcode13.tsv",
  "../output/05-G1-Library4-Flongle-Dorado-recall/modkit_summary_AYL248_barcode14.tsv"
)

# Assign sample names (in same order as files)
sample_names <- c("barcode12", "barcode13", "barcode14")

# parse summaries
parse_modkit_summary <- function(file, sample_name) {
  df <- read.table(file, sep = "\t", header = FALSE, stringsAsFactors = FALSE)
  
  # Extract values (use pattern matching on the first column)
  get_val <- function(pattern) {
    as.numeric(df$V2[grep(pattern, df$V1)])
  }
  
  tibble(
    Sample = sample_name,
    `5mC`  = get_val("^C_pass_frac_modified_m") * 100,
    `5hmC` = get_val("^C_pass_frac_modified_h") * 100,
    `6mA`  = get_val("^A_pass_frac_modified_a") * 100
  )
}

# combine and convert to long format (for ggplotting)
mod_data <- map2_dfr(files, sample_names, parse_modkit_summary)

mod_long <- mod_data %>%
  pivot_longer(cols = c(`5mC`, `5hmC`, `6mA`),
               names_to = "Modification",
               values_to = "Percent")

# plot
ggplot(mod_long, aes(x = Sample, y = Percent, fill = Modification)) +
  geom_bar(stat = "identity", width=0.5, position = position_dodge(width = 0.5)) +
  geom_text(aes(label = sprintf("%.1f", Percent)),     # format to one decimal place
            position = position_dodge(width = 0.5), 
            vjust = -0.5, size = 4) +                  # adjust spacing & text size
  labs(
    title = "Modified Base Composition per Sample (trimmed, mapped reads)",
    y = "% Modified Bases (Pass Fraction)",
    x = NULL
  )

```

## genome coverage summaries

```{r, engine='bash', eval=TRUE}
source .bashvars
cd ${output_dir_top}

# conda create -n myenv
conda activate mosdepth_env
conda config --add channels bioconda
conda config --add channels conda-forge
conda config --add channels defaults
conda install -c bioconda mosdepth
mosdepth --version

```




